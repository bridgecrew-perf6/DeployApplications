include:
  project: gcp-solutions/hcls/claims-modernization/gitlab-ci
  file: .gitlab-ci-build-vars.yml

variables:
  SECRET: regcred # used for the secret to access Images stored in Gitlab from the GKE
  CONTAINER_REGISTRY: "registry.gitlab.com"

  APP_PATH: ${CI_PROJECT_NAMESPACE} # Namespace of the Projects with Application Images. Assumption: All of them are under same hierarchy with ProjectName==ApplicationName. In this example all Applications are in the sane namespace as this file.
  APP_REPO: ${CONTAINER_REGISTRY}/${APP_PATH}

  # Commenting Out any of the KUBE_CONTEXT line will disable deployment into that environment.
  #Sharing same Agent, but could use different agents
  KUBE_CONTEXT_DEMO: "gcp-solutions/hcls/claims-modernization/gitlab-test-examples/gitlab-gke:gitlab-agent-priorauth"
  KUBE_CONTEXT_TEST: "gcp-solutions/hcls/claims-modernization/gitlab-test-examples/gitlab-gke:gitlab-agent-priorauth"



stages:
- deploy

image: google/cloud-sdk

.kube-context:
  before_script:
  - echo "Setting KUBE_CONTEXT to $KUBE_CONTEXT"
  - if [ -n "$KUBE_CONTEXT" ]; then kubectl config use-context "$KUBE_CONTEXT"; fi
  - kubectl config current-context


.cluster_patch: &cluster_patch #TODO only patch Image
- echo "Patching image $IMAGE of application $APPLICATION"
- if [ -n "$CI_COMMIT_BRANCH" ]; then echo source branch is  $CI_COMMIT_BRANCH; fi
- if [ -n "$CI_MERGE_REQUEST_SOURCE_BRANCH_SHA" ]; then echo triggered my merge Request $CI_MERGE_REQUEST_SOURCE_BRANCH_SHA; fi
- K8S=$CI_PROJECT_DIR/applications/$UPSTREAM_PROJECT_NAME/k8s
- kubectl apply -f $K8S/service.yaml --namespace="$NAMESPACE"
- sed 's|__IMAGE_TAG__|'"$IMAGE"'|g;' $K8S/deployment.sample.yaml > $K8S/deployment.yaml
- kubectl apply -f $K8S/deployment.yaml --namespace="$NAMESPACE"
- kubectl get svc $APPLICATION -n "$NAMESPACE" 2>/dev/null || kubectl expose deployment $APPLICATION --port=5001 --target-port=80 -n "$NAMESPACE" --type=LoadBalancer
- kubectl get pods -n "$NAMESPACE"

# Depends on GITLAB_AUTH - File defined inside Project Settings->CI/CD
# Generated using:
# docker login -u <user_name> -p <gitlab_access_token> registry.gitlab.com
# cat $HOME/.docker/config.json
.prepare_cluster: &prepare_cluster
# Create Secret if not existing to PullImages from GitLab
- |
  if [ -n "$NAMESPACE" ]; then
    kubectl get namespace "$NAMESPACE" 2>/dev/null || kubectl create namespace "$NAMESPACE"
    if kubectl get secrets --namespace=$NAMESPACE | grep $SECRET; then
      echo "$SECRET exists in namespace $NAMESPACE, skipping..."
    else
      kubectl create secret generic $SECRET --from-file=.dockerconfigjson=${GITLAB_AUTH} --type=kubernetes.io/dockerconfigjson --namespace=$NAMESPACE
    fi
  fi

.echo: &echo
- echo $KUBE_CONTEXT
- echo ENVIRONMENT = $ENVIRONMENT
- echo IMAGE = $IMAGE
- echo NAMESPACE = $NAMESPACE
- echo KUBE_CONTEXT=$KUBE_CONTEXT
- echo UPSTREAM_PROJECT_NAME = $UPSTREAM_PROJECT_NAME
- echo UPSTREAM_PROJECT_PATH = $UPSTREAM_PROJECT
- echo Patching image $IMAGE of application $UPSTREAM_PROJECT_NAME, using $ENVIRONMENT environment and $NAMESPACE namespace
- echo CI_COMMIT_BRANCH = $CI_COMMIT_BRANCH
- echo CI_MERGE_REQUEST_SOURCE_BRANCH_SHA = $CI_MERGE_REQUEST_SOURCE_BRANCH_SHA
- echo CI_PIPELINE_SOURCE = $CI_PIPELINE_SOURCE
- echo CI_PIPELINE_TRIGGERED = $CI_PIPELINE_TRIGGERED
- echo PIPELINE_TRIGGERED = $PIPELINE_TRIGGERED


# Pipeline was triggered - check the branch
patch:
  stage: deploy
  environment:
    name: $ENVIRONMENT
  extends: [ .kube-context ]
  script:
  - APPLICATION=$UPSTREAM_PROJECT_NAME
  - *echo
  - *prepare_cluster
  - *cluster_patch
  rules:
  - if: '$PIPELINE_TRIGGERED == null'
    when: never
  - !reference [.deploy, rules]

#check_image_exists:
#  image: debian:buster
#  before_script:
#  - apt update && apt install -y curl jq
#  script:
#  - export IMAGE_NAME=$IMAGE_LATEST
#  - echo $IMAGE_LATEST
#  - 'export IMAGE_NAME=$(echo $CI_REGISTRY_IMAGE) | cut -d "/" -f2-)'
#  - 'export GITLAB_TOKEN=$(curl -s --user "${CI_REGISTRY_USER}:${CI_REGISTRY_PASSWORD}" "https://gitlab.cc-asp.fraunhofer.de/jwt/auth?offline_token=true&service=container_registry&scope=repository:${IMAGE_NAME}:pull" | jq -r ".token")'
#  - 'if ! curl --fail -s -o /dev/null -H "Accept: application/vnd.docker.distribution.manifest.v2+json" -H "Authorization: Bearer $GITLAB_TOKEN" "https://${CI_REGISTRY}/v2/${IMAGE_NAME}/manifests/${IMAGE_TAG}"; then echo ERROR ${IMAGE_NAME}:${IMAGE_TAG} does not exist; exit 1; fi'
#  - 'echo Deploying ${IMAGE_NAME}:${IMAGE_TAG}'
#  rules:
#  - !reference [.deploy, rules]

.deployold:
  rules:
  - !reference [.build_vars, rules]
  - if: '$KUBE_CONTEXT == null'
    when: never
  script:
  - set -x
  - *echo
  - *prepare_cluster
  - echo IMAGE_TYPE=$IMAGE_TYPE
  - kubectl get pods -n "$NAMESPACE"
  - kubectl config view
  - kubectl config current-context
  - |
    for dir in ${CI_PROJECT_DIR}/applications/*/
    do
        APPLICATION_NAME=$(basename ${dir%*/})
        if [ -f errors ]; then rm errors; fi
        IMAGE=${APPLICATION_REPO}/${APPLICATION_NAME}/${CI_COMMIT_REF_SLUG-:}/${IMAGE_TYPE}


        echo $FAILED
        if [ -n "$FAILED" ]; then
          echo "Image $IMAGE_TAG does not exist, will try the Fall back Image option"
        else
          echo Deploying ${IMAGE_TAG}
        fi

        APPLY="${CI_PROJECT_DIR}/applications/${APPLICATION}/gcp/apply.sh"
        APPLICATION=$APPLICATION IMAGE=$IMAGE_TAG KUBE_NAMESPACE=$NAMESPACE bash $APPLY
    done
  - kubectl get pods -n "$NAMESPACE"

#deploy:
#  environment: $ENVIRONMENT
#  stage: deploy
#  before_script:
#    - apt update && apt install -y curl jq
#    - mkdir -p ~/.docker
#    - "echo '{\"experimental\": \"enabled\"}' > ~/.docker/config.json"
#    - docker login -u gitlab-ci-token -p $CI_JOB_TOKEN $CI_REGISTRY
#    - docker manifest inspect $IMGNAME:$IMGTAG && exit || true
#    - !reference [.kube-context, before_script]
##  extends: [ .kube-context ]
#  script:
#    - !reference [.deploy, script]
#  rules:
#    - if: $PIPELINE_TRIGGERED
#      when: never
#    - !reference [.deploy, rules]

.deploy_applications: &deploy_applications
- *echo
- *prepare_cluster
- kubectl get pods -n "$NAMESPACE"
- kubectl config view
- kubectl config current-context
- echo $IMAGE_TYPE
# Check if Container Image Exists, by setting IMAGE_EXISTS to 'true' or 'false'.
# via https://gitlab.com/gitlab-org/gitlab-foss/issues/26866#note_97609397
- mkdir -p ~/.docker
- "echo '{\"experimental\": \"enabled\"}' > ~/.docker/config.json"
- docker login -u gitlab-ci-token -p $CI_JOB_TOKEN $CI_REGISTRY
-  |
  for dir in ${CI_PROJECT_DIR}/applications/*/
  do
      APP_NAME=$(basename ${dir%*/})
      IMAGE="${APP_REPO}/${APP_NAME}/${REPO_SUB:-}${IMAGE_TYPE}"
      IMAGE_RELEASED="${APP_REPO}/${APP_NAME}/${RELEASED}"
      echo IMAGE=$IMAGE, IMAGE_RELEASED=$IMAGE_RELEASED
      docker manifest inspect $IMAGE > /dev/null 2>&1 && IMAGE_EXISTS=0 || IMAGE_EXISTS=1
      echo $IMAGE, $IMAGE_EXISTS
      if [ $IMAGE_EXISTS -eq '1' ]; then
          docker manifest inspect $IMAGE_RELEASED > /dev/null 2>&1 && IMAGE_EXISTS=0 || IMAGE_EXISTS=1
          if [ $IMAGE_EXISTS -eq '0' ]; then IMAGE=$IMAGE_RELEASED; fi
      fi
      echo $IMAGE, $IMAGE_EXISTS
  done
- kubectl get pods -n "$NAMESPACE"

.containerExists: &containerExists
# Check if Container Image Exists, by setting IMAGE_EXISTS to 'true' or 'false'.
# via https://gitlab.com/gitlab-org/gitlab-foss/issues/26866#note_97609397
- mkdir -p ~/.docker
- "echo '{\"experimental\": \"enabled\"}' > ~/.docker/config.json"
- docker login -u gitlab-ci-token -p $CI_JOB_TOKEN $CI_REGISTRY
- docker manifest inspect $IMAGE_REPO > /dev/null 2>&1 && IMAGE_EXISTS=true || IMAGE_EXISTS=false
- echo IMAGE_EXISTS=$IMAGE_EXISTS

.commit_rules:
  rules:
  - if: $PIPELINE_TRIGGERED
    when: never
  - if: $CI_COMMIT_BRANCH == null
    when: never
  - !reference [.build_vars, rules]

.mr_rules:
  rules:
  - if: $PIPELINE_TRIGGERED
    when: never
  - if: $CI_COMMIT_BRANCH == null
    when: never
  - !reference [.build_vars, rules]

.deploy:
  stage: deploy
  variables:
    REPO_SUB: ${CI_COMMIT_BRANCH:-$CI_MERGE_REQUEST_SOURCE_BRANCH_NAME}/ #for the feature, Application images are stored in the 'feature_name path
  #  extends: [.kube-context ]
  rules:
  - if: $PIPELINE_TRIGGERED
    when: never
  - if: $CI_PIPELINE_SOURCE == "merge_request_event" && $CI_MERGE_REQUEST_TARGET_BRANCH_NAME != $CI_DEFAULT_BRANCH
    when: never
  - if: $CI_PIPELINE_SOURCE == "merge_request_event" && $BRANCH_NAME != "reserved_for_mr" # GitLab issue: Not working with following check :$CI_ENVIRONMENT_NAME != "test"
    when: never
  - if: $BRANCH_NAME != $CI_COMMIT_BRANCH && $CI_PIPELINE_SOURCE != "merge_request_event"
    when: never
  - !reference [.build_vars, rules]
  script:
  - set -x
  - echo ENVIRONMENT=$CI_ENVIRONMENT_NAME
  - echo REPO_SUB=$REPO_SUB
  - echo CI_COMMIT_BRANCH=$CI_COMMIT_BRANCH
  - echo CI_MERGE_REQUEST_SOURCE_BRANCH_NAME=$CI_MERGE_REQUEST_SOURCE_BRANCH_NAME
  - echo NAMESPACE=$NAMESPACE
  - echo TEST_EVA=$TEST_EVA
#  - *deploy_applications

.ek_demo:
  stage: deploy
  rules:
  - if: '$CI_ENVIRONMENT_NAME != "james"'
    when: never
  - if: '$CI_COMMIT_TAG || $CI_COMMIT_BRANCH'
  script: echo "If you see this message, it worked"

test_for_james:
  environment:
    name: james
  extends: [.ek_demo]

test_this_should_not_run:
  environment:
    name: eva
  extends: [.ek_demo]

deploy_main:
  environment: demo
  variables:
    BRANCH_NAME: 'main'
  extends: [.deploy ]

deploy_mr:
  environment: test
  variables:
    BRANCH_NAME: 'reserved_for_mr'
  extends: [.deploy ]

deploy_feature1:
  environment: development
  variables:
    BRANCH_NAME: 'test1' #This does not work when using for example $BRANCH_FEATURE_FEATURE1, needs to be a static string.
    KUBE_CONTEXT_DEV: "gcp-solutions/hcls/claims-modernization/gitlab-test-examples/gitlab-gke:gitlab-agent-priorauth"  #This does not work when using for example $KUBE_CONTEXT_FEATURE1, needs to be a static string.
  extends: [.deploy ]

deploy_feature2:
  environment: development
  variables:
    BRANCH_NAME: 'test2' #This does not work when using for example $BRANCH_FEATURE_FEATURE1, needs to be a static string.
    KUBE_CONTEXT_DEV: "gcp-solutions/hcls/claims-modernization/gitlab-test-examples/gitlab-gke:gitlab-agent-priorauth"  #This does not work when using for example $KUBE_CONTEXT_FEATURE1, needs to be a static string.
  extends: [.deploy ]

#deploy:
#  stage: deploy
#  environment: $ENVIRONMENT
#  extends: [.set-context ]
#  rules:
#  - if: $PIPELINE_TRIGGERED
#    when: never
#  - !reference [.build_vars, rules]
#  - if: $ENVIRONMENT == 'demo'
#    variables:
#      KUBE_CONTEXT: "gcp-solutions/hcls/claims-modernization/gitlab-test-examples/gitlab-gke:gitlab-agent-priorauth"
##  - !reference [.set-context, rules]
#  script:
#  - echo CI_COMMIT_REF_NAME = $CI_COMMIT_REF_NAME
#  - echo CI_COMMIT_BRANCH = $CI_COMMIT_BRANCH
#  - *echo
##  - if [ $ENVIRONMENT -eq 'demo' ]; then KUBE_CONTEXT='eva'; fi
#  - echo KUBE_CONTEXT=$KUBE_CONTEXT
#  - *prepare_cluster
#  - echo $CI_COMMIT_REF_NAME "interesting"
#  - kubectl get pods -n "$NAMESPACE"
#  - kubectl config view
#  - kubectl config current-context
#  -  |
#    for dir in ${CI_PROJECT_DIR}/applications/*/
#    do
#        APPLICATION=$(basename ${dir%*/})
#        IMAGE="${CONTAINER_REGISTRY}/${CI_PROJECT_NAMESPACE}/${APPLICATION}/${IMAGE_TAG}"
#        APPLY="${CI_PROJECT_DIR}/applications/${APPLICATION}/gcp/apply.sh"
#        APPLICATION=$APPLICATION IMAGE=$IMAGE KUBE_NAMESPACE=$NAMESPACE bash $APPLY
#    done
#  - kubectl get pods -n "$NAMESPACE"
