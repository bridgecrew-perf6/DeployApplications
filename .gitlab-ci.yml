variables:
  KUBE_CONTEXT: "gcp-solutions/hcls/claims-modernization/gitlab-test-examples/gitlab-gke:gitlab-agent-priorauth"
  CLUSTER: development
  REGION: us-central1
  PROJECT_ID: gitlab-demo-342103
  NAMESPACE: development
  SECRET: regcred
  CONTAINER_REGISTRY: "registry.gitlab.com"

stages:
  - deploy

image: google/cloud-sdk

.kube-context:
  before_script:
#  - kubectl config view
#  - kubectl config get-contexts
  - if [ -n "$KUBE_CONTEXT" ]; then kubectl config use-context "$KUBE_CONTEXT"; fi
  - kubectl config current-context


#.cluster_connect: &cluster_connect
#- gcloud auth activate-service-account --key-file ${SERVICE_ACCOUNT_FILE} --project=$PROJECT_ID
##- gcloud container clusters get-credentials "$CLUSTER" --region="$REGION" --project "$PROJECT_ID"
##- kubectl config get-contexts
##- kubectl config use-context $KUBE_CONTEXT
##- kubectl get namespace "$NAMESPACE" 2>/dev/null || kubectl create namespace "$NAMESPACE"
##- kubectl config set-context --current --namespace=$NAMESPACE
##- kubectl config current-context
#- gcloud --quiet container clusters get-credentials $CLUSTER --region $REGION
#- kubectl get pods

.cluster_patch: &cluster_patch #TODO only patch Image
- echo "Patching image $IMAGE of application $APPLICATION"
- if [ -n "$CI_COMMIT_BRANCH" ]; then echo source branch is  $CI_COMMIT_BRANCH; fi
- if [ -n "$CI_MERGE_REQUEST_SOURCE_BRANCH_SHA" ]; then echo triggered my merge Request $CI_MERGE_REQUEST_SOURCE_BRANCH_SHA; fi
- K8S=$CI_PROJECT_DIR/applications/$UPSTREAM_PROJECT_NAME/k8s
- kubectl apply -f $K8S/service.yaml --namespace="$NAMESPACE"
- sed 's|__IMAGE_TAG__|'"$IMAGE"'|g;' $K8S/deployment.sample.yaml > $K8S/deployment.yaml
- kubectl apply -f $K8S/deployment.yaml --namespace="$NAMESPACE"
- kubectl get svc $APPLICATION -n "$NAMESPACE" 2>/dev/null || kubectl expose deployment $APPLICATION --port=5001 --target-port=80 -n "$NAMESPACE" --type=LoadBalancer
- kubectl get pods -n "$NAMESPACE"

# Depends on GITLAB_AUTH - File defined inside Project Settings->CI/CD
# Generated using:
# docker login -u <user_name> -p <gitlab_access_token> registry.gitlab.com
# cat $HOME/.docker/config.json
.prepare_cluster: &prepare_cluster
  # Create Secret if not existing to PullImages from GitLab
  - if [ -n "$NAMESPACE" ]; then kubectl get namespace "$NAMESPACE" 2>/dev/null || kubectl create namespace "$NAMESPACE"; fi
  - kubectl get secrets --namespace=$NAMESPACE
  - |
    if kubectl get secrets --namespace=$NAMESPACE | grep $SECRET; then
      echo "$SECRET exists in namespace $NAMESPACE, skipping..."
    else
      kubectl create secret generic $SECRET --from-file=.dockerconfigjson=${GITLAB_AUTH} --type=kubernetes.io/dockerconfigjson --namespace=$NAMESPACE
    fi

# Pipeline was triggered - check the branch
patch:
  stage: deploy
  environment: $ENVIRONMENT
  extends: [.kube-context]
  script:
    - echo ENVIRONMENT = $ENVIRONMENT
    - echo IMAGE = $IMAGE
    - echo NAMESPACE = $NAMESPACE
    - echo UPSTREAM_PROJECT_NAME = $UPSTREAM_PROJECT_NAME
    - echo UPSTREAM_PROJECT_PATH = $UPSTREAM_PROJECT
    - echo Patching image $IMAGE of application $UPSTREAM_PROJECT_NAME, using $ENVIRONMENT environment and $NAMESPACE namespace
    - echo CI_COMMIT_BRANCH = $CI_COMMIT_BRANCH
    - echo CI_MERGE_REQUEST_SOURCE_BRANCH_SHA = $CI_MERGE_REQUEST_SOURCE_BRANCH_SHA
    - echo CI_PIPELINE_SOURCE = $CI_PIPELINE_SOURCE
    - echo CI_PIPELINE_TRIGGERED = $CI_PIPELINE_TRIGGERED
    - echo PIPELINE_TRIGGERED = $PIPELINE_TRIGGERED
    - APPLICATION=$UPSTREAM_PROJECT_NAME
    - *prepare_cluster
    - *cluster_patch
  rules:
  - if: $PIPELINE_TRIGGERED
    when: always



deploy:
  stage: deploy
  environment: $NAMESPACE
  extends: [.kube-context]
  rules:
  - if: $PIPELINE_TRIGGERED
    when: never
  - if: $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH
    variables:
      NAMESPACE: "demo"
      IMAGE_TAG: "released:latest"
  - if: $CI_COMMIT_BRANCH && $CI_COMMIT_BRANCH != $CI_DEFAULT_BRANCH && $CI_PIPELINE_SOURCE != "merge_request_event"
    variables:
      NAMESPACE: "development"
      IMAGE_TAG: "qa:latest"
  - if: $CI_PIPELINE_SOURCE == "merge_request_event" && $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == $CI_DEFAULT_BRANCH
    variables:
      NAMESPACE: "test"
      IMAGE_TAG: "mr:latest"
  script:
    - echo PIPELINE_TRIGGERED = $PIPELINE_TRIGGERED
    - echo CI_COMMIT_REF_NAME = $CI_COMMIT_REF_NAME
    - echo CI_COMMIT_BRANCH = $CI_COMMIT_BRANCH
    - echo CI_PIPELINE_SOURCE = $CI_PIPELINE_SOURCE
    - echo CI_MERGE_REQUEST_TARGET_BRANCH_NAME = $CI_MERGE_REQUEST_TARGET_BRANCH_NAME
    - echo NAMESPACE = $NAMESPACE, PIPELINE_TRIGGERED = $PIPELINE_TRIGGERED
    - *prepare_cluster
    - echo $CI_COMMIT_REF_NAME "interesting"
    - kubectl get pods -n "$NAMESPACE"
    - kubectl config view
    - kubectl config current-context
    -  |
      for dir in ${CI_PROJECT_DIR}/applications/*/
      do
          APPLICATION=$(basename ${dir%*/})
          IMAGE="${CONTAINER_REGISTRY}/${CI_PROJECT_NAMESPACE}/${APPLICATION}/${IMAGE_TAG}"
          APPLY="${CI_PROJECT_DIR}/applications/${APPLICATION}/gcp/apply.sh"
          APPLICATION=$APPLICATION IMAGE=$IMAGE KUBE_NAMESPACE=$NAMESPACE bash $APPLY
      done
    - kubectl get pods -n "$NAMESPACE"
