variables:
  KUBE_CONTEXT: "gcp-solutions/hcls/claims-modernization/gitlab-test-examples/gitlab-gke:gitlab-agent"
  CLUSTER: development
  REGION: us-central1
  PROJECT_ID: gitlab-demo-342103
  NAMESPACE: development

stages:
  - deploy

image: google/cloud-sdk

.kube-context:
  before_script:
  - kubectl config view
  - kubectl config get-contexts
  - if [ -n "$KUBE_CONTEXT" ]; then kubectl config use-context "$KUBE_CONTEXT"; fi
  - kubectl config current-context


.cluster_connect: &cluster_connect
#TODO ADD checking ENIRONMENT variable exists and connect to cluster depending on it
- gcloud auth activate-service-account --key-file ${SERVICE_ACCOUNT_FILE} --project=$PROJECT_ID
#- gcloud container clusters get-credentials "$CLUSTER" --region="$REGION" --project "$PROJECT_ID"
#- kubectl config get-contexts
#- kubectl config use-context $KUBE_CONTEXT
#- kubectl get namespace "$NAMESPACE" 2>/dev/null || kubectl create namespace "$NAMESPACE"
#- kubectl config set-context --current --namespace=$NAMESPACE
#- kubectl config current-context
- gcloud --quiet container clusters get-credentials $CLUSTER --region $REGION
- kubectl get pods

.cluster_patch: &cluster_patch
- echo "Patching image $IMAGE of application $APPLICATION"
- if [ -n "$CI_COMMIT_BRANCH" ]; echo source branch is  $CI_COMMIT_BRANCH; fi
- if [ -n "$CI_MERGE_REQUEST_SOURCE_BRANCH_SHA" ]; echo triggered my merge Request $CI_MERGE_REQUEST_SOURCE_BRANCH_SHA; fi
- if [ -n "$NAMESPACE" ]; then kubectl get namespace "$NAMESPACE" 2>/dev/null || kubectl create namespace "$NAMESPACE"; fi
- kubectl apply -f $CI_PROJECT_DIR/$UPSTREAM_PROJECT_NAME/k8s/service.yaml --namespace="$NAMESPACE"
- sed 's|__IMAGE_TAG__|'"$IMAGE"'|g;' $CI_PROJECT_DIR/$UPSTREAM_PROJECT_NAME/k8s/deployment.sample.yaml > $CI_PROJECT_DIR/$UPSTREAM_PROJECT_NAME/k8s/deployment.yaml
- kubectl apply -f $CI_PROJECT_DIR/applications/$UPSTREAM_PROJECT_NAME/k8s/deployment.yaml --namespace="$NAMESPACE"
- kubectl get pods


### DEMO CLUSTER

### DEVELOPMENT CLUSTER

### TEST CLUSTER

# Pipeline was triggered - check the branch
patch:
  stage: deploy
  environment: __ENVIRONMENT__
  extends: [.kube-context]
  script:
    - echo ENVIRONMENT = $ENVIRONMENT
    - echo IMAGE = $IMAGE
    - echo NAMESPACE = $NAMESPACE
    - echo UPSTREAM_PROJECT_NAME = $UPSTREAM_PROJECT_NAME
    - echo UPSTREAM_PROJECT_PATH = $UPSTREAM_PROJECT
    - echo Patching image $IMAGE of application $UPSTREAM_PROJECT_NAME, using $ENVIRONMENT environment and $NAMESPACE namespace
    - echo CI_COMMIT_BRANCH = $CI_COMMIT_BRANCH
    - echo CI_MERGE_REQUEST_SOURCE_BRANCH_SHA = $CI_MERGE_REQUEST_SOURCE_BRANCH_SHA
    - echo CI_PIPELINE_SOURCE = $CI_PIPELINE_SOURCE
    - echo CI_PIPELINE_TRIGGERED = $CI_PIPELINE_TRIGGERED
    - echo PIPELINE_TRIGGERED = $PIPELINE_TRIGGERED
    - APPLICATION=$UPSTREAM_PROJECT_NAME
    - *cluster_connect
    - *cluster_patch
  rules:
  - if: $PIPELINE_TRIGGERED == 'true'
    when: always


deploy:
  stage: deploy
  extends: [.kube-context]
  rules:
  - if: $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH
    variables:
      NAMESPACE: "demo"
  script:
    - echo $CI_COMMIT_REF_NAME "interesting"
    - kubectl get pods
    - kubectl config view
    - kubectl config current-context
    - if [ -n "$NAMESPACE" ]; then kubectl get namespace "$NAMESPACE" 2>/dev/null || kubectl create namespace "$NAMESPACE"; fi
    -  |
      for dir in ${CI_PROJECT_DIR}/applications/*/
      do
          echo $dir
          echo `pwd`
          APPLICATION=$(basename ${dir%*/})
          IMAGE="${CI_PROJECT_NAMESPACE}/${APPLICATION}/released:latest"
          APPLY="${CI_PROJECT_DIR}/applications/${APPLICATION}/gcp/apply.sh"
          APPLICATION=$APPLICATION IMAGE=$IMAGE NAMESPACE=$NAMESPACE bash $APPLY
      done
#    - gcloud auth activate-service-account --key-file ${SERVICE_ACCOUNT_FILE} --project=$PROJECT_ID
#    - gcloud --quiet container clusters get-credentials $CLUSTER --region $REGION
    - kubectl get all