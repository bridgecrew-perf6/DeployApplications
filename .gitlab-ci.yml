include:
  project: gcp-solutions/hcls/claims-modernization/gitlab-ci
  file: .gitlab-ci-build-vars.yml

variables:
  SECRET: regcred # used for the secret to access Images stored in Gitlab from the GKE

  # Commenting Out any of the KUBE_CONTEXT line will disable deployment into that environment.
  KUBE_CONTEXT_DEV: "gcp-solutions/hcls/claims-modernization/gitlab-test-examples/gitlab-gke:gitlab-agent-priorauth1"
  KUBE_CONTEXT_DEMO: "gcp-solutions/hcls/claims-modernization/gitlab-test-examples/gitlab-gke:gitlab-agent-priorauth2"
  KUBE_CONTEXT_TEST: "gcp-solutions/hcls/claims-modernization/gitlab-test-examples/gitlab-gke:gitlab-agent-priorauth3"

stages:
- deploy

image: google/cloud-sdk

.kube-context:
  before_script:
  - if [ -n "$KUBE_CONTEXT" ]; then kubectl config use-context "$KUBE_CONTEXT"; fi
  - kubectl config current-context


.cluster_patch: &cluster_patch #TODO only patch Image
- echo "Patching image $IMAGE of application $APPLICATION"
- if [ -n "$CI_COMMIT_BRANCH" ]; then echo source branch is  $CI_COMMIT_BRANCH; fi
- if [ -n "$CI_MERGE_REQUEST_SOURCE_BRANCH_SHA" ]; then echo triggered my merge Request $CI_MERGE_REQUEST_SOURCE_BRANCH_SHA; fi
- K8S=$CI_PROJECT_DIR/applications/$UPSTREAM_PROJECT_NAME/k8s
- kubectl apply -f $K8S/service.yaml --namespace="$NAMESPACE"
- sed 's|__IMAGE_TAG__|'"$IMAGE"'|g;' $K8S/deployment.sample.yaml > $K8S/deployment.yaml
- kubectl apply -f $K8S/deployment.yaml --namespace="$NAMESPACE"
- kubectl get svc $APPLICATION -n "$NAMESPACE" 2>/dev/null || kubectl expose deployment $APPLICATION --port=5001 --target-port=80 -n "$NAMESPACE" --type=LoadBalancer
- kubectl get pods -n "$NAMESPACE"

# Depends on GITLAB_AUTH - File defined inside Project Settings->CI/CD
# Generated using:
# docker login -u <user_name> -p <gitlab_access_token> registry.gitlab.com
# cat $HOME/.docker/config.json
.prepare_cluster: &prepare_cluster
# Create Secret if not existing to PullImages from GitLab
- |
  if [ -n "$NAMESPACE" ]; then
    kubectl get namespace "$NAMESPACE" 2>/dev/null || kubectl create namespace "$NAMESPACE"
    if kubectl get secrets --namespace=$NAMESPACE | grep $SECRET; then
      echo "$SECRET exists in namespace $NAMESPACE, skipping..."
    else
      kubectl create secret generic $SECRET --from-file=.dockerconfigjson=${GITLAB_AUTH} --type=kubernetes.io/dockerconfigjson --namespace=$NAMESPACE
    fi
  fi

.echo: &echo
- echo $KUBE_CONTEXT
- echo ENVIRONMENT = $ENVIRONMENT
- echo IMAGE = $IMAGE
- echo NAMESPACE = $NAMESPACE
- echo UPSTREAM_PROJECT_NAME = $UPSTREAM_PROJECT_NAME
- echo UPSTREAM_PROJECT_PATH = $UPSTREAM_PROJECT
- echo Patching image $IMAGE of application $UPSTREAM_PROJECT_NAME, using $ENVIRONMENT environment and $NAMESPACE namespace
- echo CI_COMMIT_BRANCH = $CI_COMMIT_BRANCH
- echo CI_MERGE_REQUEST_SOURCE_BRANCH_SHA = $CI_MERGE_REQUEST_SOURCE_BRANCH_SHA
- echo CI_PIPELINE_SOURCE = $CI_PIPELINE_SOURCE
- echo CI_PIPELINE_TRIGGERED = $CI_PIPELINE_TRIGGERED
- echo PIPELINE_TRIGGERED = $PIPELINE_TRIGGERED
- echo APPLICATON=$APPLICATION

# Pipeline was triggered - check the branch
patch:
  stage: deploy
  environment: $ENVIRONMENT
  extends: [ .kube-context ]
  script:
  - APPLICATION=$UPSTREAM_PROJECT_NAME
  - *echo
  #    - *prepare_cluster
  #    - *cluster_patch
  rules:
    - if: $KUBE_CONTEXT
    - if: $PIPELINE_TRIGGERED
      when: always


.set_environment:
  rules:
  - !reference [.build_rules, rules]

deploy demo:
  environment: demo
  stage: deploy
#  extends: .set_environment
  after_script:
  - echo ENVIRONMENT = $ENVIRONMENT
  - echo KUBE_CONTEXT = $KUBE_CONTEXT
  script:
  - echo KUBE_CONTEXT = $KUBE_CONTEXT
  rules:
  - if: $PIPELINE_TRIGGERED
    when: never
  - !reference [.build_rules, rules]
  - if: '$KUBE_CONTEXT == null'
    when: never
#    - if: $ENVIRONMENT == $TEST_ENV_NAME || $ENVIRONMENT == $DEV_ENV_NAME
#      when: never

#deploy:
#  stage: deploy
#  environment: $ENVIRONMENT
#  extends: [.set-context ]
#  rules:
#  - if: $PIPELINE_TRIGGERED
#    when: never
#  - !reference [.build_rules, rules]
#  - if: $ENVIRONMENT == 'demo'
#    variables:
#      KUBE_CONTEXT: "gcp-solutions/hcls/claims-modernization/gitlab-test-examples/gitlab-gke:gitlab-agent-priorauth"
##  - !reference [.set-context, rules]
#  script:
#  - echo CI_COMMIT_REF_NAME = $CI_COMMIT_REF_NAME
#  - echo CI_COMMIT_BRANCH = $CI_COMMIT_BRANCH
#  - *echo
##  - if [ $ENVIRONMENT -eq 'demo' ]; then KUBE_CONTEXT='eva'; fi
#  - echo KUBE_CONTEXT=$KUBE_CONTEXT
##  - *prepare_cluster
##  - echo $CI_COMMIT_REF_NAME "interesting"
##  - kubectl get pods -n "$NAMESPACE"
##  - kubectl config view
##  - kubectl config current-context
##  -  |
##    for dir in ${CI_PROJECT_DIR}/applications/*/
##    do
##        APPLICATION=$(basename ${dir%*/})
##        IMAGE="${CONTAINER_REGISTRY}/${CI_PROJECT_NAMESPACE}/${APPLICATION}/${IMAGE_TAG}"
##        APPLY="${CI_PROJECT_DIR}/applications/${APPLICATION}/gcp/apply.sh"
##        APPLICATION=$APPLICATION IMAGE=$IMAGE KUBE_NAMESPACE=$NAMESPACE bash $APPLY
##    done
##  - kubectl get pods -n "$NAMESPACE"
